<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>CONNECTIONARY</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        @keyframes confetti {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }
        .dragging {
            opacity: 0.5;
            cursor: grabbing;
            animation: pulse 0.5s infinite;
        }
        .drag-over {
            background: rgba(59, 130, 246, 0.2) !important;
            border-color: rgb(59, 130, 246) !important;
            transform: scale(1.08);
            transition: all 0.2s;
        }
        .locked-cell {
            background: linear-gradient(135deg, #fbbf24, #f59e0b) !important;
            cursor: not-allowed !important;
            position: relative;
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.3);
        }
        .word-item {
            cursor: grab;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            transition: transform 0.2s;
        }
        .word-item:hover {
            transform: scale(1.05);
        }
        .word-item:active {
            cursor: grabbing;
        }
        .theme-complete {
            animation: slideIn 0.5s ease-out;
        }
        .confetti-piece {
            position: fixed;
            width: 10px;
            height: 10px;
            animation: confetti 3s ease-out forwards;
            pointer-events: none;
            z-index: 1000;
        }
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .modal-content {
            animation: slideIn 0.3s ease-out;
        }
        .progress-bar {
            transition: width 0.5s ease-out;
        }
        .star {
            color: #fbbf24;
            filter: drop-shadow(0 0 2px rgba(251, 191, 36, 0.5));
        }
        .quadrant-icon {
            position: absolute;
            font-size: 48px;
            z-index: 50;
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s ease-out;
            filter: drop-shadow(0 0 8px rgba(0, 0, 0, 0.5));
            pointer-events: none;
        }
        .quadrant-icon.active {
            opacity: 1;
            transform: scale(1);
            animation: iconPop 0.5s ease-out;
        }
        @keyframes iconPop {
            0% { transform: scale(0) rotate(0deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
    </style>
</head>
<body class="bg-slate-900">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // All puzzles including original and new ones
        const PUZZLES = [
            {
                id: 1,
                title: "Squared Circle",
                description: "Actions, items, and communication",
                centerWord: "RING",
                solutions: [
                    [["HOOK", "TITLE", "AWARD"],["TELEGRAPH", "RING", "WATCH"],["CALL", "CABLE", "TAPE"]],
                    [["CALL", "TELEGRAPH", "HOOK"],["CABLE", "RING", "TITLE"],["TAPE", "WATCH", "AWARD"]],
                    [["AWARD", "WATCH", "TAPE"],["TITLE", "RING", "CABLE"],["HOOK", "TELEGRAPH", "CALL"]],
                    [["TAPE", "CABLE", "CALL"],["WATCH", "RING", "TELEGRAPH"],["AWARD", "TITLE", "HOOK"]],
                    [["AWARD", "TITLE", "HOOK"],["WATCH", "RING", "TELEGRAPH"],["TAPE", "CABLE", "CALL"]],
                    [["TAPE", "WATCH", "AWARD"],["CABLE", "RING", "TITLE"],["CALL", "TELEGRAPH", "HOOK"]],
                    [["CALL", "CABLE", "TAPE"],["TELEGRAPH", "RING", "WATCH"],["HOOK", "TITLE", "AWARD"]],
                    [["HOOK", "TELEGRAPH", "CALL"],["TITLE", "RING", "CABLE"],["AWARD", "WATCH", "TAPE"]]
                ],
                allWords: ["HOOK", "TITLE", "AWARD", "TELEGRAPH", "WATCH", "CALL", "CABLE", "TAPE"],
                quadrantClues: [
                    { clue: "BOXING TERMS", words: ["HOOK", "TITLE", "TELEGRAPH", "RING"], color: "blue", icon: "ü•ä" },
                    { clue: "ITEMS THAT CAN BE 'GIVEN'", words: ["TITLE", "AWARD", "WATCH", "RING"], color: "green", icon: "üéÅ" },
                    { clue: "VERBS OF COMMUNICATION", words: ["TELEGRAPH", "CALL", "CABLE", "RING"], color: "purple", icon: "üí¨" },
                    { clue: "THINGS THAT ENCIRCLE", words: ["WATCH", "TAPE", "CABLE", "RING"], color: "orange", icon: "‚≠ï" }
                ],
                explanations: {
                    "HOOK": "A type of punch in boxing.",
                    "TITLE": "A boxing championship / An honor.",
                    "AWARD": "Something given for achievement.",
                    "TELEGRAPH": "To signal a punch / A method of communication.",
                    "RING": "Boxing arena / A gift / To call someone / An encircling band.",
                    "WATCH": "A gift item / Encircles the wrist.",
                    "CALL": "To communicate by phone.",
                    "CABLE": "To send a message / An encircling cord.",
                    "TAPE": "Used to wrap or encircle things."
                },
                hints: []
            },
            {
                id: 2,
                title: "Leaf Through This",
                description: "Objects, data, and furniture",
                centerWord: "TABLE",
                solutions: [
                    [["SPINE", "LEAF", "CHAIR"],["INDEX", "TABLE", "COUNTER"],["COMPASS", "GRAPH", "DIAGRAM"]],
                    [["COMPASS", "INDEX", "SPINE"],["GRAPH", "TABLE", "LEAF"],["DIAGRAM", "COUNTER", "CHAIR"]],
                    [["CHAIR", "COUNTER", "DIAGRAM"],["LEAF", "TABLE", "GRAPH"],["SPINE", "INDEX", "COMPASS"]],
                    [["DIAGRAM", "GRAPH", "COMPASS"],["COUNTER", "TABLE", "INDEX"],["CHAIR", "LEAF", "SPINE"]],
                    [["CHAIR", "LEAF", "SPINE"],["COUNTER", "TABLE", "INDEX"],["DIAGRAM", "GRAPH", "COMPASS"]],
                    [["DIAGRAM", "COUNTER", "CHAIR"],["GRAPH", "TABLE", "LEAF"],["COMPASS", "INDEX", "SPINE"]],
                    [["SPINE", "INDEX", "COMPASS"],["LEAF", "TABLE", "GRAPH"],["CHAIR", "COUNTER", "DIAGRAM"]],
                    [["COMPASS", "GRAPH", "DIAGRAM"],["INDEX", "TABLE", "COUNTER"],["SPINE", "LEAF", "CHAIR"]]
                ],
                allWords: ["SPINE", "LEAF", "CHAIR", "INDEX", "COUNTER", "COMPASS", "GRAPH", "DIAGRAM"],
                quadrantClues: [
                    { clue: "PARTS OF A BOOK", words: ["SPINE","LEAF","INDEX","TABLE"], color: "blue", icon: "üìö" },
                    { clue: "ITEMS OF FURNITURE", words: ["LEAF","CHAIR","TABLE","COUNTER"], color: "green", icon: "üõãÔ∏è" },
                    { clue: "FEATURES OF A MAP", words: ["INDEX","TABLE","COMPASS","GRAPH"], color: "purple", icon: "üß≠" },
                    { clue: "ELEMENTS OF A DATA REPORT", words: ["TABLE","COUNTER","GRAPH","DIAGRAM"], color: "orange", icon: "üìä" }
                ],
                explanations: {
                    "SPINE": "A part of a book.",
                    "LEAF": "A page in a book / A section of a dining table.",
                    "CHAIR": "An item of furniture.",
                    "INDEX": "A section of a book / A feature on a map.",
                    "TABLE": "Table of contents / An item of furniture / A chart on a map / A data-set in a report.",
                    "COUNTER": "A piece of furniture / An element in a data report.",
                    "COMPASS": "A feature on a map.",
                    "GRAPH": "A feature on a map / An element in a data report.",
                    "DIAGRAM": "An element in a data report."
                },
                hints: []
            },
            {
                id: 3,
                title: "The Punchline",
                description: "Fighting, comedy, drinks, and tools",
                centerWord: "PUNCH",
                solutions: [
                    [["UPPERCUT", "RIPOSTE", "SKIT"],["SMASH", "PUNCH", "BIT"],["NEGRONI", "SCREWDRIVER", "AWL"]],
                    [["SKIT", "BIT", "AWL"],["RIPOSTE", "PUNCH", "SCREWDRIVER"],["UPPERCUT", "SMASH", "NEGRONI"]],
                    [["AWL", "SCREWDRIVER", "NEGRONI"],["BIT", "PUNCH", "SMASH"],["SKIT", "RIPOSTE", "UPPERCUT"]],
                    [["NEGRONI", "SMASH", "UPPERCUT"],["SCREWDRIVER", "PUNCH", "RIPOSTE"],["AWL", "BIT", "SKIT"]],
                    [["SKIT", "RIPOSTE", "UPPERCUT"],["BIT", "PUNCH", "SMASH"],["AWL", "SCREWDRIVER", "NEGRONI"]],
                    [["AWL", "BIT", "SKIT"],["SCREWDRIVER", "PUNCH", "RIPOSTE"],["NEGRONI", "SMASH", "UPPERCUT"]],
                    [["NEGRONI", "SCREWDRIVER", "AWL"],["SMASH", "PUNCH", "BIT"],["UPPERCUT", "RIPOSTE", "SKIT"]],
                    [["UPPERCUT", "SMASH", "NEGRONI"],["RIPOSTE", "PUNCH", "SCREWDRIVER"],["SKIT", "BIT", "AWL"]]
                ],
                allWords: ["UPPERCUT", "RIPOSTE", "SKIT", "SMASH", "BIT", "NEGRONI", "SCREWDRIVER", "AWL"],
                quadrantClues: [
                    { clue: "FIGHTING TERMS", words: ["UPPERCUT", "RIPOSTE", "SMASH", "PUNCH"], color: "blue", icon: "ü§∫" },
                    { clue: "COMEDY TERMS", words: ["RIPOSTE", "SKIT", "PUNCH", "BIT"], color: "green", icon: "üòÇ" },
                    { clue: "COCKTAILS", words: ["SMASH", "PUNCH", "NEGRONI", "SCREWDRIVER"], color: "purple", icon: "üç∏" },
                    { clue: "HAND TOOLS", words: ["PUNCH", "BIT", "SCREWDRIVER", "AWL"], color: "orange", icon: "üõ†Ô∏è" }
                ],
                explanations: {
                    "UPPERCUT": "An upward boxing punch.",
                    "RIPOSTE": "A quick counter-attack in fencing or boxing / A witty comeback.",
                    "SKIT": "A short comedy sketch.",
                    "SMASH": "A powerful hit in boxing / A cocktail with fruit and spirits.",
                    "PUNCH": "A boxing strike / A comedy punchline / A fruity party drink / A tool for making holes.",
                    "BIT": "A comedy routine / A drill attachment tool.",
                    "NEGRONI": "An Italian cocktail with gin, vermouth, and Campari.",
                    "SCREWDRIVER": "A vodka and orange juice cocktail / A tool for driving screws.",
                    "AWL": "A pointed tool for making holes in leather or wood."
                },
                hints: []
            },
            {
                id: 4,
                title: "Storm Warning",
                description: "Motion, machinery, fabric, and weather",
                centerWord: "BOLT",
                solutions: [
                    [["AXLE", "SPRING", "DASH"],["PIN", "BOLT", "SURGE"],["SEAM", "SHEET", "HAIL"]],
                    [["SEAM", "PIN", "AXLE"],["SHEET", "BOLT", "SPRING"],["HAIL", "SURGE", "DASH"]],
                    [["HAIL", "SHEET", "SEAM"],["SURGE", "BOLT", "PIN"],["DASH", "SPRING", "AXLE"]],
                    [["DASH", "SURGE", "HAIL"],["SPRING", "BOLT", "SHEET"],["AXLE", "PIN", "SEAM"]],
                    [["DASH", "SPRING", "AXLE"],["SURGE", "BOLT", "PIN"],["HAIL", "SHEET", "SEAM"]],
                    [["HAIL", "SURGE", "DASH"],["SHEET", "BOLT", "SPRING"],["SEAM", "PIN", "AXLE"]],
                    [["AXLE", "PIN", "SEAM"],["SPRING", "BOLT", "SHEET"],["DASH", "SURGE", "HAIL"]],
                    [["SEAM", "SHEET", "HAIL"],["PIN", "BOLT", "SURGE"],["AXLE", "SPRING", "DASH"]]
                ],
                allWords: ["AXLE","SPRING","DASH","PIN","SURGE","SEAM","SHEET","HAIL"],
                quadrantClues: [
                    { clue: "MECHANICAL COMPONENTS", words: ["AXLE","SPRING","PIN","BOLT"], color: "blue", icon: "üî©" },
                    { clue: "VERBS OF SUDDEN MOVEMENT", words: ["SPRING","DASH","BOLT","SURGE"], color: "green", icon: "üèÉ" },
                    { clue: "SEWING & FABRIC TERMS", words: ["PIN","BOLT","SEAM","SHEET"], color: "purple", icon: "üßµ" },
                    { clue: "WEATHER & STORM TERMS", words: ["BOLT","SURGE","SHEET","HAIL"], color: "orange", icon: "‚õàÔ∏è" }
                ],
                explanations: {
                    "AXLE": "A mechanical component.",
                    "SPRING": "A mechanical component / To move suddenly.",
                    "DASH": "To move suddenly.",
                    "PIN": "A mechanical component / A sewing item.",
                    "BOLT": "A mechanical fastener / To move suddenly / A roll of fabric / A bolt of lightning.",
                    "SURGE": "To move suddenly / A storm surge in weather.",
                    "SEAM": "A term in sewing.",
                    "SHEET": "A sheet of fabric / A sheet of ice/rain.",
                    "HAIL": "A type of weather."
                },
                hints: []
            },
            {
                id: 5,
                title: "Measure for Measure",
                description: "Music, mountains, measuring, and mise en place",
                centerWord: "SCALE",
                solutions: [
                    [["OCTAVE", "PITCH", "BELAY"],["METER", "SCALE", "SCRAMBLE"],["CALIPER", "TARE", "DICE"]],
                    [["CALIPER", "METER", "OCTAVE"],["TARE", "SCALE", "PITCH"],["DICE", "SCRAMBLE", "BELAY"]],
                    [["DICE", "TARE", "CALIPER"],["SCRAMBLE", "SCALE", "METER"],["BELAY", "PITCH", "OCTAVE"]],
                    [["BELAY", "SCRAMBLE", "DICE"],["PITCH", "SCALE", "TARE"],["OCTAVE", "METER", "CALIPER"]],
                    [["BELAY", "PITCH", "OCTAVE"],["SCRAMBLE", "SCALE", "METER"],["DICE", "TARE", "CALIPER"]],
                    [["DICE", "SCRAMBLE", "BELAY"],["TARE", "SCALE", "PITCH"],["CALIPER", "METER", "OCTAVE"]],
                    [["OCTAVE", "METER", "CALIPER"],["PITCH", "SCALE", "TARE"],["BELAY", "SCRAMBLE", "DICE"]],
                    [["CALIPER", "TARE", "DICE"],["METER", "SCALE", "SCRAMBLE"],["OCTAVE", "PITCH", "BELAY"]]
                ],
                allWords: ["OCTAVE","PITCH","BELAY","METER","SCRAMBLE","CALIPER","TARE","DICE"],
                quadrantClues: [
                    { clue: "MUSIC TERMS", words: ["OCTAVE","PITCH","METER","SCALE"], color: "blue", icon: "üéº" },
                    { clue: "CLIMBING & MOUNTAINEERING TERMS", words: ["PITCH","BELAY","SCALE","SCRAMBLE"], color: "green", icon: "üßó" },
                    { clue: "MEASURING INSTRUMENTS & FUNCTIONS", words: ["METER","SCALE","CALIPER","TARE"], color: "purple", icon: "üìè" },
                    { clue: "KITCHEN PREP & COOKING VERBS", words: ["SCALE","SCRAMBLE","TARE","DICE"], color: "orange", icon: "üç≥" }
                ],
                explanations: {
                    "OCTAVE": "A series of 8 notes in music.",
                    "PITCH": "A musical tone / A steep section in climbing.",
                    "BELAY": "To secure a rope while climbing.",
                    "METER": "Musical rhythm / A measuring device.",
                    "SCALE": "Musical notes in order / To climb / A weighing device / To remove fish scales.",
                    "SCRAMBLE": "A type of easy climb / To mix eggs while cooking.",
                    "CALIPER": "A precision measuring instrument.",
                    "TARE": "To zero out a scale / Weight of an empty container.",
                    "DICE": "To cut food into small cubes."
                },
                hints: []
            },
            {
                id: 6,
                title: "Under Fire",
                description: "Thermodynamics, kitchen, law, and sport",
                centerWord: "HEAT",
                solutions: [
                    [["THERMAL", "BOIL", "SEAR"],["HOT", "HEAT", "SEASON"],["WARRANT", "BOOK", "LAP"]],
                    [["WARRANT", "HOT", "THERMAL"],["BOOK", "HEAT", "BOIL"],["LAP", "SEASON", "SEAR"]],
                    [["SEAR", "SEASON", "LAP"],["BOIL", "HEAT", "BOOK"],["THERMAL", "HOT", "WARRANT"]],
                    [["LAP", "BOOK", "WARRANT"],["SEASON", "HEAT", "HOT"],["SEAR", "BOIL", "THERMAL"]],
                    [["SEAR", "BOIL", "THERMAL"],["SEASON", "HEAT", "HOT"],["LAP", "BOOK", "WARRANT"]],
                    [["LAP", "SEASON", "SEAR"],["BOOK", "HEAT", "BOIL"],["WARRANT", "HOT", "THERMAL"]],
                    [["THERMAL", "HOT", "WARRANT"],["BOIL", "HEAT", "BOOK"],["SEAR", "SEASON", "LAP"]],
                    [["WARRANT", "BOOK", "LAP"],["HOT", "HEAT", "SEASON"],["THERMAL", "BOIL", "SEAR"]]
                ],
                allWords: ["THERMAL","BOIL","SEAR","HOT","SEASON","WARRANT","BOOK","LAP"],
                quadrantClues: [
                    { clue: "THERMODYNAMICS & PHYSICS TERMS", words: ["THERMAL","BOIL","HOT","HEAT"], color: "blue", icon: "üî•" },
                    { clue: "COOKING & FOOD-PREP VERBS", words: ["BOIL","SEAR","HEAT","SEASON"], color: "orange", icon: "üç≥" },
                    { clue: "LAW ENFORCEMENT & JUSTICE TERMS", words: ["HOT","HEAT","WARRANT","BOOK"], color: "purple", icon: "üöî" },
                    { clue: "SPORTS & COMPETITION TERMS", words: ["HEAT","SEASON","BOOK","LAP"], color: "green", icon: "üèÅ" }
                ],
                explanations: {
                    "THERMAL": "Relating to heat.",
                    "BOIL": "A liquid's change of state / A method of cooking.",
                    "SEAR": "A cooking technique using high heat.",
                    "HOT": "High in temperature / Slang for stolen goods.",
                    "HEAT": "A form of energy / To warm up food / Slang for police / A qualifying race.",
                    "SEASON": "To add flavor to food / A period of play for a sport.",
                    "WARRANT": "A legal document for an arrest.",
                    "BOOK": "To charge with a crime / To penalize in a game, like soccer or rugby.",
                    "LAP": "A circuit in a race."
                },
                hints: []
            },
            {
                id: 7,
                title: "Break a Leg",
                description: "Theater, medicine, fishing, and metalwork",
                centerWord: "CAST",
                solutions: [
                    [["CURTAIN", "DRESSING", "SUTURE"],["LINE", "CAST", "BRACE"],["REEL", "LEAD", "ANVIL"]],
                    [["REEL", "LINE", "CURTAIN"],["LEAD", "CAST", "DRESSING"],["ANVIL", "BRACE", "SUTURE"]],
                    [["SUTURE", "BRACE", "ANVIL"],["DRESSING", "CAST", "LEAD"],["CURTAIN", "LINE", "REEL"]],
                    [["ANVIL", "LEAD", "REEL"],["BRACE", "CAST", "LINE"],["SUTURE", "DRESSING", "CURTAIN"]],
                    [["SUTURE", "DRESSING", "CURTAIN"],["BRACE", "CAST", "LINE"],["ANVIL", "LEAD", "REEL"]],
                    [["ANVIL", "BRACE", "SUTURE"],["LEAD", "CAST", "DRESSING"],["REEL", "LINE", "CURTAIN"]],
                    [["CURTAIN", "LINE", "REEL"],["DRESSING", "CAST", "LEAD"],["SUTURE", "BRACE", "ANVIL"]],
                    [["REEL", "LEAD", "ANVIL"],["LINE", "CAST", "BRACE"],["CURTAIN", "DRESSING", "SUTURE"]]
                ],
                allWords: ["CURTAIN","DRESSING","SUTURE","LINE","BRACE","REEL","LEAD","ANVIL"],
                quadrantClues: [
                    { clue: "THEATER & PERFORMANCE TERMS", words: ["CURTAIN","DRESSING","LINE","CAST"], color: "blue", icon: "üé≠" },
                    { clue: "MEDICAL EQUIPMENT & TREATMENTS", words: ["DRESSING","SUTURE","CAST","BRACE"], color: "green", icon: "üè•" },
                    { clue: "FISHING EQUIPMENT & TECHNIQUES", words: ["LINE","CAST","REEL","LEAD"], color: "purple", icon: "üé£" },
                    { clue: "METALWORKING & FOUNDRY TERMS", words: ["CAST","BRACE","LEAD","ANVIL"], color: "orange", icon: "‚öíÔ∏è" }
                ],
                explanations: {
                    "CURTAIN": "A theater screen.",
                    "DRESSING": "Theater dressing room / A medical wound cover.",
                    "SUTURE": "Medical stitches.",
                    "LINE": "A line of dialogue / A fishing line.",
                    "CAST": "The cast of a play / A plaster cast / To cast a line / To cast metal.",
                    "BRACE": "A medical brace / A structural metal brace.",
                    "REEL": "A fishing reel.",
                    "LEAD": "A lead fishing sinker / The metal, lead.",
                    "ANVIL": "A metalworking tool."
                },
                hints: []
            },
            {
                id: 8,
                title: "Mind the Gap",
                description: "Mind, money, neurons, and signals",
                centerWord: "IMPULSE",
                solutions: [
                    [["ANXIETY", "WITHDRAWAL", "RECEIPT"],["INHIBITION", "IMPULSE", "CHARGE"],["AXON", "POTENTIAL", "RESISTOR"]],
                    [["AXON", "INHIBITION", "ANXIETY"],["POTENTIAL", "IMPULSE", "WITHDRAWAL"],["RESISTOR", "CHARGE", "RECEIPT"]],
                    [["RECEIPT", "CHARGE", "RESISTOR"],["WITHDRAWAL", "IMPULSE", "POTENTIAL"],["ANXIETY", "INHIBITION", "AXON"]],
                    [["RESISTOR", "POTENTIAL", "AXON"],["CHARGE", "IMPULSE", "INHIBITION"],["RECEIPT", "WITHDRAWAL", "ANXIETY"]],
                    [["RECEIPT", "WITHDRAWAL", "ANXIETY"],["CHARGE", "IMPULSE", "INHIBITION"],["RESISTOR", "POTENTIAL", "AXON"]],
                    [["RESISTOR", "CHARGE", "RECEIPT"],["POTENTIAL", "IMPULSE", "WITHDRAWAL"],["AXON", "INHIBITION", "ANXIETY"]],
                    [["ANXIETY", "INHIBITION", "AXON"],["WITHDRAWAL", "IMPULSE", "POTENTIAL"],["RECEIPT", "CHARGE", "RESISTOR"]],
                    [["AXON", "POTENTIAL", "RESISTOR"],["INHIBITION", "IMPULSE", "CHARGE"],["ANXIETY", "WITHDRAWAL", "RECEIPT"]]
                ],
                allWords: ["ANXIETY","WITHDRAWAL","RECEIPT","INHIBITION","CHARGE","AXON","POTENTIAL","RESISTOR"],
                quadrantClues: [
                    { clue: "PSYCHIATRY & CLINICAL PSYCHOLOGY", words: ["ANXIETY","WITHDRAWAL","INHIBITION","IMPULSE"], color: "blue", icon: "üß†" },
                    { clue: "PAYMENTS & CONSUMER PURCHASES", words: ["WITHDRAWAL","RECEIPT","IMPULSE","CHARGE"], color: "green", icon: "üí≥" },
                    { clue: "NEUROSCIENCE & NEUROPHYSIOLOGY", words: ["INHIBITION","IMPULSE","AXON","POTENTIAL"], color: "purple", icon: "üß¨" },
                    { clue: "ELECTRICITY & CIRCUITS", words: ["IMPULSE","CHARGE","POTENTIAL","RESISTOR"], color: "orange", icon: "‚ö°" }
                ],
                explanations: {
                    "ANXIETY": "A condition studied in clinical psychology.",
                    "WITHDRAWAL": "A psychological symptom / Taking money from an account.",
                    "RECEIPT": "Proof of a consumer purchase.",
                    "INHIBITION": "Behavioral restraint or shyness in psychology / Suppression of nerve signals in neuroscience.",
                    "IMPULSE": "A psychological urge / An impulse purchase / A nerve signal / An electrical signal.",
                    "CHARGE": "To charge for a purchase / An electrical charge.",
                    "AXON": "The part of a neuron that carries impulses.",
                    "POTENTIAL": "An action potential in neuroscience / Electrical potential (voltage).",
                    "RESISTOR": "A component in an electrical circuit."
                },
                hints: []
            },
            {
                id: 9,
                title: "The Gambit",
                description: "Games, art, finance, and journalism",
                centerWord: "PIECE",
                solutions: [
                    [["PAWN", "MINIATURE", "STATUE"],["CHECKER", "PIECE", "LOT"],["SCOOP", "STOCK", "SHARE"]],
                    [["SCOOP", "CHECKER", "PAWN"],["STOCK", "PIECE", "MINIATURE"],["SHARE", "LOT", "STATUE"]],
                    [["STATUE", "LOT", "SHARE"],["MINIATURE", "PIECE", "STOCK"],["PAWN", "CHECKER", "SCOOP"]],
                    [["SHARE", "STOCK", "SCOOP"],["LOT", "PIECE", "CHECKER"],["STATUE", "MINIATURE", "PAWN"]],
                    [["STATUE", "MINIATURE", "PAWN"],["LOT", "PIECE", "CHECKER"],["SHARE", "STOCK", "SCOOP"]],
                    [["SHARE", "LOT", "STATUE"],["STOCK", "PIECE", "MINIATURE"],["SCOOP", "CHECKER", "PAWN"]],
                    [["PAWN", "CHECKER", "SCOOP"],["MINIATURE", "PIECE", "STOCK"],["STATUE", "LOT", "SHARE"]],
                    [["SCOOP", "STOCK", "SHARE"],["CHECKER", "PIECE", "LOT"],["PAWN", "MINIATURE", "STATUE"]]
                ],
                allWords: ["PAWN", "MINIATURE", "STATUE", "CHECKER", "LOT", "SCOOP", "STOCK", "SHARE"],
                quadrantClues: [
                    { clue: "BOARD GAME COMPONENTS", words: ["PAWN","MINIATURE","CHECKER","PIECE"], color: "blue", icon: "üé≤" },
                    { clue: "TERMS FOR ARTWORK", words: ["MINIATURE","STATUE","PIECE","LOT"], color: "green", icon: "üé®" },
                    { clue: "PRINT MEDIA TERMS", words: ["CHECKER","PIECE","SCOOP","STOCK"], color: "purple", icon: "üì∞" },
                    { clue: "FINANCIAL STAKES", words: ["PIECE","LOT","STOCK","SHARE"], color: "orange", icon: "üìà" }
                ],
                explanations: {
                    "PAWN": "The most numerous piece in the game of chess.",
                    "MINIATURE": "A small, detailed model used as a game piece / A small, highly detailed portrait.",
                    "STATUE": "A carved or cast figure as a work of art.",
                    "CHECKER": "A piece used in checkers / A fact-checker in media.",
                    "PIECE": "A token in a board game / An artwork / A written article / A share of a business.",
                    "LOT": "An item or set of items for sale at auction / A bundle of shares.",
                    "SCOOP": "An exclusive news story.",
                    "STOCK": "A stock photo used in media / An ownership share in a company.",
                    "SHARE": "A unit of ownership in a corporation or financial asset."
                },
                hints: []
            },
            {
                id: 10,
                title: "Rolling Stone",
                description: "A puzzle of sport, building, kitchen prep, and color.",
                centerWord: "STONE",
                solutions: [
                    [["BIRDIE", "MARBLE", "GRANITE"],["SEED", "STONE", "SLATE"],["PIT", "BROWN", "TAUPE"]],
                    [["PIT", "SEED", "BIRDIE"],["BROWN", "STONE", "MARBLE"],["TAUPE", "SLATE", "GRANITE"]],
                    [["TAUPE", "BROWN", "PIT"],["SLATE", "STONE", "SEED"],["GRANITE", "MARBLE", "BIRDIE"]],
                    [["GRANITE", "SLATE", "TAUPE"],["MARBLE", "STONE", "BROWN"],["BIRDIE", "SEED", "PIT"]],
                    [["GRANITE", "MARBLE", "BIRDIE"],["SLATE", "STONE", "SEED"],["TAUPE", "BROWN", "PIT"]],
                    [["TAUPE", "SLATE", "GRANITE"],["BROWN", "STONE", "MARBLE"],["PIT", "SEED", "BIRDIE"]],
                    [["BIRDIE", "SEED", "PIT"],["MARBLE", "STONE", "BROWN"],["GRANITE", "SLATE", "TAUPE"]],
                    [["PIT", "BROWN", "TAUPE"],["SEED", "STONE", "SLATE"],["BIRDIE", "MARBLE", "GRANITE"]]
                ],
                allWords: ["BIRDIE", "MARBLE", "GRANITE", "SEED", "SLATE", "PIT", "BROWN", "TAUPE"],
                quadrantClues: [
                    { clue: "SPORTS & GAMES TERMS", words: ["BIRDIE", "MARBLE", "SEED", "STONE"], color: "blue", icon: "üèüÔ∏è" },
                    { clue: "BUILDING STONE MATERIALS", words: ["MARBLE", "GRANITE", "SLATE", "STONE"], color: "green", icon: "üèõÔ∏è" },
                    { clue: "KITCHEN PREP VERBS", words: ["SEED", "STONE", "PIT", "BROWN"], color: "purple", icon: "üç≥" },
                    { clue: "COLOR WORDS", words: ["SLATE", "STONE", "BROWN", "TAUPE"], color: "orange", icon: "üé®" }
                ],
                explanations: {
                    "BIRDIE": "A score of one under par in golf.",
                    "MARBLE": "A game piece / A type of stone.",
                    "GRANITE": "A type of building stone.",
                    "SEED": "A tournament ranking / To remove seeds from fruit.",
                    "STONE": "A playing piece in Go or curling / A building material / To remove a stone from fruit / A color.",
                    "SLATE": "A type of building stone / A color.",
                    "PIT": "To remove a pit from fruit.",
                    "BROWN": "To cook something until brown / A color.",
                    "TAUPE": "A brownish-gray color."
                },
                hints: []
            }
        ];

        function ConnectionaryGame() {
            const [currentScreen, setCurrentScreen] = useState('gallery'); // 'gallery' or 'game'
            const [currentPuzzleIndex, setCurrentPuzzleIndex] = useState(0);
            const [grid, setGrid] = useState([]);
            const [shuffledClues, setShuffledClues] = useState([]);
            const [draggedItem, setDraggedItem] = useState(null);
            const [solved, setSolved] = useState(false);
            const [completedThemes, setCompletedThemes] = useState([]);
            const [moves, setMoves] = useState(0);
            const [hintsUsed, setHintsUsed] = useState(0);
            const [showHint, setShowHint] = useState(false);
            const [currentHint, setCurrentHint] = useState('');
            const [timer, setTimer] = useState(0);
            const [isTimerRunning, setIsTimerRunning] = useState(false);
            const [selectedCell, setSelectedCell] = useState(null);
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [showTutorial, setShowTutorial] = useState(false);
            const [completedPuzzles, setCompletedPuzzles] = useState([]);
            const [stats, setStats] = useState({
                puzzlesCompleted: 0,
                totalMoves: 0,
                totalTime: 0,
                totalHints: 0,
                bestScores: {}
            });

            const currentGameData = PUZZLES[currentPuzzleIndex];

            // Load saved data from localStorage
            useEffect(() => {
                const savedStats = localStorage.getItem('connectionaryStats');
                if (savedStats) {
                    setStats(JSON.parse(savedStats));
                }
                const savedCompleted = localStorage.getItem('connectionaryCompletedPuzzles');
                if (savedCompleted) {
                    setCompletedPuzzles(JSON.parse(savedCompleted));
                }
                const savedTutorial = localStorage.getItem('connectionaryTutorialShown');
                if (!savedTutorial && currentScreen === 'game') {
                    setShowTutorial(true);
                    localStorage.setItem('connectionaryTutorialShown', 'true');
                }
            }, []);

            // Timer effect
            useEffect(() => {
                let interval;
                if (isTimerRunning && !solved && currentScreen === 'game') {
                    interval = setInterval(() => {
                        setTimer(t => t + 1);
                    }, 1000);
                } else {
                    clearInterval(interval);
                }
                return () => clearInterval(interval);
            }, [isTimerRunning, solved, currentScreen]);

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const calculateScore = () => {
                const baseScore = 1000;
                const movePenalty = moves * 10;
                const timePenalty = Math.floor(timer / 10) * 5;
                const hintPenalty = hintsUsed * 50;
                return Math.max(100, baseScore - movePenalty - timePenalty - hintPenalty);
            };

            const shuffleArray = (array) => {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            };

            const selectPuzzle = (index) => {
                setCurrentPuzzleIndex(index);
                setCurrentScreen('game');
                // Tutorial shows on first game play
                const savedTutorial = localStorage.getItem('connectionaryTutorialShown');
                if (!savedTutorial) {
                    setShowTutorial(true);
                    localStorage.setItem('connectionaryTutorialShown', 'true');
                }
            };

            const backToGallery = () => {
                setCurrentScreen('gallery');
            };

            const initializeGame = () => {
                const primarySolution = currentGameData.solutions[0].flat();
                const allMovableWords = [...currentGameData.allWords];
                
                let finalGrid;
                let shuffleAttempts = 0;
                const MAX_SHUFFLE_ATTEMPTS = 100;

                const checkForCompleteQuadrants = (candidateGrid) => {
                    // Check all four quadrants to see if any are complete
                    const physicalQuadrantPositions = [
                        [[0,0],[0,1],[1,0],[1,1]],
                        [[0,1],[0,2],[1,1],[1,2]],
                        [[1,0],[1,1],[2,0],[2,1]],
                        [[1,1],[1,2],[2,1],[2,2]]
                    ];

                    for (const positions of physicalQuadrantPositions) {
                        const playerQuadrantWords = positions.map(([r, c]) => candidateGrid[posToIndex(r, c)]);
                        
                        // Check against all valid solutions
                        for (const solution of currentGameData.solutions) {
                            const solutionGrid = solution.flat();
                            const solutionQuadrantWords = positions.map(([r, c]) => solutionGrid[posToIndex(r, c)]);
                            
                            // If this quadrant matches exactly, it's complete
                            if (JSON.stringify(playerQuadrantWords) === JSON.stringify(solutionQuadrantWords)) {
                                return true; // Found a complete quadrant
                            }
                        }
                    }
                    return false; // No complete quadrants found
                };

                do {
                    let candidateMovable = shuffleArray(allMovableWords);
                    let candidateGrid = [];
                    let movableIndex = 0;
                    
                    for(let i = 0; i < 9; i++) {
                        if (i === 4) {
                            candidateGrid.push(currentGameData.centerWord);
                        } else {
                            candidateGrid.push(candidateMovable[movableIndex++]);
                        }
                    }
                    
                    // Check if any quadrants are complete
                    const hasCompleteQuadrant = checkForCompleteQuadrants(candidateGrid);
                    
                    // Also check that it's not already solved
                    const currentGridStr = JSON.stringify(candidateGrid);
                    let isAlreadySolved = false;
                    for (const solution of currentGameData.solutions) {
                        if (currentGridStr === JSON.stringify(solution.flat())) {
                            isAlreadySolved = true;
                            break;
                        }
                    }
                    
                    // Accept the grid if no quadrants are complete and it's not solved
                    if (!hasCompleteQuadrant && !isAlreadySolved) {
                        finalGrid = candidateGrid;
                        break;
                    }

                    shuffleAttempts++;
                    if (shuffleAttempts >= MAX_SHUFFLE_ATTEMPTS) {
                        // If we can't find a good shuffle, just use the last attempt
                        finalGrid = candidateGrid;
                        break;
                    }
                } while (true);
                
                setGrid(finalGrid);
                setShuffledClues(shuffleArray(currentGameData.quadrantClues));
                setSolved(false);
                setCompletedThemes([]);
                setMoves(0);
                setHintsUsed(0);
                setShowHint(false);
                setTimer(0);
                setIsTimerRunning(true);
                setHistory([finalGrid]);
                setHistoryIndex(0);
                setSelectedCell(null);
            };

            useEffect(() => {
                if (currentScreen === 'game') {
                    initializeGame();
                }
            }, [currentPuzzleIndex, currentScreen]);

            const posToIndex = (row, col) => row * 3 + col;

            const findThemeForWords = (words) => {
                const sortedWords = [...words].sort();
                return currentGameData.quadrantClues.find(theme => 
                    JSON.stringify([...theme.words].sort()) === JSON.stringify(sortedWords)
                );
            };

            useEffect(() => {
                if (!currentGameData || grid.length === 0 || currentScreen !== 'game') return;

                const newCompletedThemes = [];
                const physicalQuadrantPositions = [
                    [[0,0],[0,1],[1,0],[1,1]],
                    [[0,1],[0,2],[1,1],[1,2]],
                    [[1,0],[1,1],[2,0],[2,1]],
                    [[1,1],[1,2],[2,1],[2,2]]
                ];

                physicalQuadrantPositions.forEach((positions) => {
                    const playerQuadrantWords = positions.map(([r, c]) => grid[posToIndex(r, c)]);
                    for (const solution of currentGameData.solutions) {
                        const solutionGrid = solution.flat();
                        const solutionQuadrantWords = positions.map(([r, c]) => solutionGrid[posToIndex(r, c)]);
                        if (JSON.stringify(playerQuadrantWords) === JSON.stringify(solutionQuadrantWords)) {
                            const theme = findThemeForWords(playerQuadrantWords);
                            if (theme && !newCompletedThemes.includes(theme.clue)) {
                                newCompletedThemes.push(theme.clue);
                            }
                        }
                    }
                });
                
                // Check for newly completed themes
                if (newCompletedThemes.length > completedThemes.length) {
                    const newTheme = newCompletedThemes.find(t => !completedThemes.includes(t));
                    if (newTheme) {
                        const element = document.querySelector(`[data-theme="${newTheme}"]`);
                        if (element) {
                            element.classList.add('theme-complete');
                            setTimeout(() => element.classList.remove('theme-complete'), 500);
                        }
                    }
                }
                
                setCompletedThemes(newCompletedThemes);

                const currentGridStr = JSON.stringify(grid);
                for (const solution of currentGameData.solutions) {
                    if (currentGridStr === JSON.stringify(solution.flat())) {
                        setSolved(true);
                        setIsTimerRunning(false);
                        
                        // Update completed puzzles
                        if (!completedPuzzles.includes(currentGameData.id)) {
                            const newCompleted = [...completedPuzzles, currentGameData.id];
                            setCompletedPuzzles(newCompleted);
                            localStorage.setItem('connectionaryCompletedPuzzles', JSON.stringify(newCompleted));
                        }
                        
                        // Update statistics
                        const newStats = {...stats};
                        newStats.puzzlesCompleted++;
                        newStats.totalMoves += moves;
                        newStats.totalTime += timer;
                        newStats.totalHints += hintsUsed;
                        
                        const score = calculateScore();
                        if (!newStats.bestScores[currentGameData.id] || score > newStats.bestScores[currentGameData.id]) {
                            newStats.bestScores[currentGameData.id] = score;
                        }
                        
                        setStats(newStats);
                        localStorage.setItem('connectionaryStats', JSON.stringify(newStats));
                        return;
                    }
                }
            }, [grid, currentScreen]);

            const performMove = (sourceIndex, targetIndex) => {
                if (sourceIndex === targetIndex || sourceIndex === 4 || targetIndex === 4) return;
                
                const newGrid = [...grid];
                [newGrid[sourceIndex], newGrid[targetIndex]] = [newGrid[targetIndex], newGrid[sourceIndex]];
                
                setGrid(newGrid);
                setMoves(moves + 1);
                
                // Add to history for undo/redo
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(newGrid);
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            const performDrop = (dropIndex = null) => {
                if (!draggedItem || dropIndex === null || solved) return;
                const { index: sourceIndex } = draggedItem;
                performMove(sourceIndex, dropIndex);
                setDraggedItem(null);
            };

            // Keyboard controls
            useEffect(() => {
                if (currentScreen !== 'game') return;
                
                const handleKeyPress = (e) => {
                    if (solved) return;
                    
                    // Undo/Redo
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 'z' && historyIndex > 0) {
                            setGrid(history[historyIndex - 1]);
                            setHistoryIndex(historyIndex - 1);
                        } else if (e.key === 'y' && historyIndex < history.length - 1) {
                            setGrid(history[historyIndex + 1]);
                            setHistoryIndex(historyIndex + 1);
                        }
                        return;
                    }
                    
                    // Cell selection with number keys
                    if (e.key >= '1' && e.key <= '9') {
                        const index = parseInt(e.key) - 1;
                        if (index === 4) return; // Center cell
                        if (selectedCell === null) {
                            setSelectedCell(index);
                        } else {
                            performMove(selectedCell, index);
                            setSelectedCell(null);
                        }
                    }
                    
                    // Escape to deselect
                    if (e.key === 'Escape') {
                        setSelectedCell(null);
                    }
                    
                    // H for hint
                    if (e.key === 'h' || e.key === 'H') {
                        getHint();
                    }
                };
                
                window.addEventListener('keydown', handleKeyPress);
                return () => window.removeEventListener('keydown', handleKeyPress);
            }, [selectedCell, solved, historyIndex, history, currentScreen]);

            const getHint = () => {
                if (!currentGameData.hints || currentGameData.hints.length === 0) {
                    setCurrentHint("No hints available for this puzzle");
                    setShowHint(true);
                    return;
                }
                if (hintsUsed >= currentGameData.hints.length) {
                    setCurrentHint("No more hints available!");
                } else {
                    setCurrentHint(currentGameData.hints[hintsUsed]);
                    setHintsUsed(hintsUsed + 1);
                }
                setShowHint(true);
            };
            
            const handleDragStart = (e, word, index) => { 
                if (!solved && index !== 4) { 
                    setDraggedItem({ word, index }); 
                    e.target.classList.add('dragging');
                    setSelectedCell(null);
                } 
            };
            
            const handleDragEnd = (e) => e.target.classList.remove('dragging');
            const handleDragOver = (e) => e.preventDefault();
            const handleDrop = (e, dropIndex) => { 
                e.preventDefault(); 
                e.currentTarget.classList.remove('drag-over'); 
                performDrop(dropIndex); 
            };
            const handleDragEnter = (e) => { if (!solved) e.currentTarget.classList.add('drag-over'); };
            const handleDragLeave = (e) => e.currentTarget.classList.remove('drag-over');

            const handleCellClick = (index) => {
                if (solved || index === 4) return;
                
                if (selectedCell === null) {
                    setSelectedCell(index);
                } else if (selectedCell === index) {
                    setSelectedCell(null);
                } else {
                    performMove(selectedCell, index);
                    setSelectedCell(null);
                }
            };

            const nextPuzzle = () => {
                if (currentPuzzleIndex < PUZZLES.length - 1) {
                    setCurrentPuzzleIndex(currentPuzzleIndex + 1);
                } else {
                    setCurrentPuzzleIndex(0);
                }
            };

            // Puzzle Gallery Screen
            if (currentScreen === 'gallery') {
                return (
                    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 md:p-8">
                        <div className="max-w-6xl mx-auto">
                            <div className="text-center mb-8">
                                <h1 className="text-4xl md:text-5xl font-bold text-white mb-3">CONNECTIONARY</h1>
                                <p className="text-slate-300 text-lg">Choose a puzzle to play</p>
                                <div className="mt-4 text-slate-400">
                                    {completedPuzzles.length} of {PUZZLES.length} puzzles completed
                                </div>
                            </div>
                            
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                {PUZZLES.map((puzzle, index) => {
                                    const isCompleted = completedPuzzles.includes(puzzle.id);
                                    const bestScore = stats.bestScores[puzzle.id];
                                    
                                    return (
                                        <div 
                                            key={puzzle.id}
                                            onClick={() => selectPuzzle(index)}
                                            className="bg-slate-800 rounded-xl p-6 cursor-pointer transform transition-all hover:scale-105 hover:bg-slate-700 relative"
                                        >
                                            <h3 className="text-2xl font-bold text-white mb-3">{puzzle.title}</h3>
                                            
                                            <p className="text-slate-400 text-sm mb-3">{puzzle.description}</p>
                                            
                                            {bestScore && (
                                                <div className="text-center">
                                                    <span className="text-yellow-400 text-sm">Best Score: {bestScore}</span>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                            
                            <div className="text-center mt-8">
                                <button 
                                    onClick={() => setShowTutorial(true)}
                                    className="text-blue-400 hover:text-blue-300 underline"
                                >
                                    How to Play
                                </button>
                            </div>
                        </div>
                        
                        {/* Tutorial Modal for Gallery */}
                        {showTutorial && (
                            <div className="modal">
                                <div className="modal-content bg-slate-800 rounded-xl p-6 max-w-md mx-4">
                                    <h2 className="text-2xl font-bold text-white mb-4">How to Play Connectionary</h2>
                                    <div className="space-y-3 text-slate-300 text-sm">
                                        <p>üéØ <strong>Goal:</strong> Arrange words so each 2√ó2 quadrant matches a theme</p>
                                        <p>üîí <strong>Center:</strong> The golden center word is locked and connects all themes</p>
                                        <p>üñ±Ô∏è <strong>Controls:</strong> Drag & drop words, or click to select and swap</p>
                                        <p>‚å®Ô∏è <strong>Shortcuts:</strong> Use 1-9 keys, Ctrl+Z (undo), H (hint)</p>
                                        <p>üí° <strong>Strategy:</strong> The center word belongs to ALL four themes!</p>
                                    </div>
                                    <button 
                                        onClick={() => setShowTutorial(false)} 
                                        className="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                    >
                                        Got it!
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>
                );
            }

            // Game Screen
            if (!grid.length) {
                return <div className="min-h-screen flex items-center justify-center text-white">
                    <div className="text-center">
                        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-blue-500 mx-auto mb-4"></div>
                        <p>Loading puzzle...</p>
                    </div>
                </div>;
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 md:p-8">
                    {/* Tutorial Modal */}
                    {showTutorial && (
                        <div className="modal">
                            <div className="modal-content bg-slate-800 rounded-xl p-6 max-w-md mx-4">
                                <h2 className="text-2xl font-bold text-white mb-4">How to Play Connectionary</h2>
                                <div className="space-y-3 text-slate-300 text-sm">
                                    <p>üéØ <strong>Goal:</strong> Arrange words so each 2√ó2 quadrant matches a theme</p>
                                    <p>üîí <strong>Center:</strong> The golden center word is locked and connects all themes</p>
                                    <p>üñ±Ô∏è <strong>Controls:</strong> Drag & drop words, or click to select and swap</p>
                                    <p>‚å®Ô∏è <strong>Shortcuts:</strong> Use 1-9 keys, Ctrl+Z (undo), H (hint)</p>
                                    <p>üí° <strong>Strategy:</strong> The center word belongs to ALL four themes!</p>
                                </div>
                                <button 
                                    onClick={() => setShowTutorial(false)} 
                                    className="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                >
                                    Got it! Let's Play
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="max-w-6xl mx-auto">
                        {/* Header */}
                        <div className="text-center mb-6">
                            <button 
                                onClick={backToGallery}
                                className="absolute left-4 top-4 text-slate-400 hover:text-white transition-colors"
                            >
                                ‚Üê Back to Gallery
                            </button>
                            <h1 className="text-3xl md:text-4xl font-bold text-white mb-2">CONNECTIONARY</h1>
                            <p className="text-slate-300 text-sm md:text-base">
                                Puzzle {currentGameData.id} of {PUZZLES.length} ‚Ä¢ {currentGameData.title}
                            </p>
                        </div>
                        
                        <div className="grid grid-cols-1 lg:grid-cols-5 gap-6">
                            {/* Left Panel */}
                            <div className="lg:col-span-2">
                                {/* Status Bar */}
                                <div className="bg-slate-800 rounded-lg p-4 mb-4">
                                    <h3 className="text-white font-bold text-lg mb-2">{currentGameData.title}</h3>
                                    <p className="text-slate-300 text-sm mb-3">{currentGameData.description}</p>
                                    <div className="grid grid-cols-3 gap-2 text-center">
                                        <div>
                                            <div className="text-2xl font-bold text-white">{moves}</div>
                                            <div className="text-xs text-slate-400">Moves</div>
                                        </div>
                                        <div>
                                            <div className="text-2xl font-bold text-white">{formatTime(timer)}</div>
                                            <div className="text-xs text-slate-400">Time</div>
                                        </div>
                                        <div>
                                            <div className="text-2xl font-bold text-white">{calculateScore()}</div>
                                            <div className="text-xs text-slate-400">Score</div>
                                        </div>
                                    </div>
                                    {/* Progress Bar */}
                                    <div className="mt-3 bg-slate-700 rounded-full h-2 overflow-hidden">
                                        <div 
                                            className="progress-bar bg-gradient-to-r from-blue-500 to-green-500 h-full rounded-full"
                                            style={{ width: `${(completedThemes.length / 4) * 100}%` }}
                                        ></div>
                                    </div>
                                </div>

                                {/* Themes */}
                                <div className="space-y-3 mb-6">
                                    <h3 className="text-white font-bold">The Four Themes:</h3>
                                    {shuffledClues.map((quad, displayIdx) => {
                                        const isCompleted = completedThemes.includes(quad.clue);
                                        return (
                                            <div 
                                                key={displayIdx} 
                                                data-theme={quad.clue}
                                                className={`p-3 rounded-lg border-2 transition-all ${
                                                    isCompleted ? 'border-green-400 bg-green-900 bg-opacity-30' : 'border-slate-600'
                                                } ${
                                                    quad.color === 'blue' ? 'bg-blue-900 bg-opacity-30' : 
                                                    quad.color === 'green' ? 'bg-green-900 bg-opacity-30' : 
                                                    quad.color === 'purple' ? 'bg-purple-900 bg-opacity-30' : 
                                                    'bg-orange-900 bg-opacity-30'
                                                }`}
                                            >
                                                <div className={`text-sm font-semibold transition-colors ${
                                                    isCompleted ? 'text-green-400' : 'text-slate-300'
                                                }`}>
                                                    {isCompleted && '‚úì '}{quad.clue}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>

                                {/* Hint Section */}
                                {showHint && currentHint && (
                                    <div className="mb-4 bg-yellow-900 bg-opacity-30 border-2 border-yellow-600 rounded-lg p-3">
                                        <div className="text-yellow-300 text-sm">
                                            <strong>üí° Hint:</strong> {currentHint}
                                        </div>
                                    </div>
                                )}

                                {/* Controls */}
                                <div className="space-y-3">
                                    {!solved ? (
                                        <>
                                            <div className="grid grid-cols-2 gap-2">
                                                <button 
                                                    onClick={() => {
                                                        if (historyIndex > 0) {
                                                            setGrid(history[historyIndex - 1]);
                                                            setHistoryIndex(historyIndex - 1);
                                                        }
                                                    }}
                                                    disabled={historyIndex <= 0 || solved}
                                                    className="bg-slate-600 hover:bg-slate-700 disabled:bg-slate-800 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm"
                                                >
                                                    ‚Ü∂ Undo
                                                </button>
                                                <button 
                                                    onClick={() => {
                                                        if (historyIndex < history.length - 1) {
                                                            setGrid(history[historyIndex + 1]);
                                                            setHistoryIndex(historyIndex + 1);
                                                        }
                                                    }}
                                                    disabled={historyIndex >= history.length - 1 || solved}
                                                    className="bg-slate-600 hover:bg-slate-700 disabled:bg-slate-800 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm"
                                                >
                                                    ‚Ü∑ Redo
                                                </button>
                                            </div>
                                            
                                            {currentGameData.hints && currentGameData.hints.length > 0 && (
                                                <button 
                                                    onClick={getHint}
                                                    disabled={solved || hintsUsed >= currentGameData.hints.length}
                                                    className="w-full bg-yellow-600 hover:bg-yellow-700 disabled:bg-slate-800 disabled:opacity-50 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                                >
                                                    üí° Get Hint ({currentGameData.hints.length - hintsUsed} left)
                                                </button>
                                            )}
                                            
                                            <button 
                                                onClick={initializeGame} 
                                                className="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                            >
                                                üîÑ Reset Puzzle
                                            </button>
                                        </>
                                    ) : (
                                        <>
                                            <div className="bg-green-800 bg-opacity-50 rounded-lg p-4 text-center">
                                                <h3 className="text-2xl font-bold text-green-400 mb-2">‚úì Puzzle Complete!</h3>
                                                <p className="text-white text-lg">Score: {calculateScore()} points</p>
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <button 
                                                    onClick={initializeGame} 
                                                    className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                                >
                                                    Play Again
                                                </button>
                                                <button 
                                                    onClick={nextPuzzle} 
                                                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                                >
                                                    Next Puzzle
                                                </button>
                                            </div>
                                            <button 
                                                onClick={backToGallery} 
                                                className="w-full bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                            >
                                                Back to Gallery
                                            </button>
                                        </>
                                    )}
                                    
                                    <button 
                                        onClick={() => setShowTutorial(true)} 
                                        className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                                    >
                                        üìñ How to Play
                                    </button>
                                </div>
                            </div>

                            {/* Game Grid */}
                            <div className="lg:col-span-3">
                                <div className="bg-white rounded-xl shadow-2xl p-6">
                                    <div className="relative">
                                        {/* Quadrant Completion Icons */}
                                        {(() => {
                                            const quadrantPositions = [
                                                { positions: [0,1,3,4], style: { top: '-16px', left: '-16px' } },      // top-left
                                                { positions: [1,2,4,5], style: { top: '-16px', right: '-16px' } },     // top-right
                                                { positions: [3,4,6,7], style: { bottom: '-16px', left: '-16px' } },   // bottom-left
                                                { positions: [4,5,7,8], style: { bottom: '-16px', right: '-16px' } }   // bottom-right
                                            ];
                                            
                                            return quadrantPositions.map((quadrant, qIdx) => {
                                                const quadrantWords = quadrant.positions.map(pos => grid[pos]);
                                                
                                                // Find if this quadrant is complete
                                                let completedTheme = null;
                                                for (const solution of currentGameData.solutions) {
                                                    const solutionGrid = solution.flat();
                                                    const solutionQuadrantWords = quadrant.positions.map(pos => solutionGrid[pos]);
                                                    
                                                    if (JSON.stringify(quadrantWords) === JSON.stringify(solutionQuadrantWords)) {
                                                        // Find the matching theme
                                                        completedTheme = currentGameData.quadrantClues.find(clue => 
                                                            clue.words.every(w => quadrantWords.includes(w))
                                                        );
                                                        break;
                                                    }
                                                }
                                                
                                                if (completedTheme && completedTheme.icon) {
                                                    return (
                                                        <div 
                                                            key={qIdx}
                                                            className={`quadrant-icon ${completedThemes.includes(completedTheme.clue) ? 'active' : ''}`}
                                                            style={quadrant.style}
                                                        >
                                                            {completedTheme.icon}
                                                        </div>
                                                    );
                                                }
                                                return null;
                                            });
                                        })()}
                                        
                                        <div className="grid grid-cols-3 gap-3 md:gap-4">
                                        {grid.map((word, idx) => {
                                            const isCenter = idx === 4;
                                            const isSelected = selectedCell === idx;
                                            
                                            // Get position-based explanation when solved
                                            let explanationText = '';
                                            if (solved && currentGameData.explanations) {
                                                const row = Math.floor(idx / 3);
                                                const col = idx % 3;
                                                
                                                if (isCenter) {
                                                    // Center word - show simplified multi-meaning
                                                    explanationText = currentGameData.explanations[word];
                                                } else {
                                                    // For other words, determine which quadrants they belong to
                                                    const quadrants = [];
                                                    
                                                    // Top-left quadrant (positions 0,1,3,4)
                                                    if ((row === 0 && col === 0) || (row === 0 && col === 1) || 
                                                        (row === 1 && col === 0) || (row === 1 && col === 1)) {
                                                        const topLeftWords = [grid[0], grid[1], grid[3], grid[4]];
                                                        currentGameData.quadrantClues.forEach(clue => {
                                                            if (clue.words.includes(word) && 
                                                                clue.words.every(w => topLeftWords.includes(w))) {
                                                                quadrants.push(clue.clue);
                                                            }
                                                        });
                                                    }
                                                    
                                                    // Top-right quadrant (positions 1,2,4,5)
                                                    if ((row === 0 && col === 1) || (row === 0 && col === 2) || 
                                                        (row === 1 && col === 1) || (row === 1 && col === 2)) {
                                                        const topRightWords = [grid[1], grid[2], grid[4], grid[5]];
                                                        currentGameData.quadrantClues.forEach(clue => {
                                                            if (clue.words.includes(word) && 
                                                                clue.words.every(w => topRightWords.includes(w))) {
                                                                quadrants.push(clue.clue);
                                                            }
                                                        });
                                                    }
                                                    
                                                    // Bottom-left quadrant (positions 3,4,6,7)
                                                    if ((row === 1 && col === 0) || (row === 1 && col === 1) || 
                                                        (row === 2 && col === 0) || (row === 2 && col === 1)) {
                                                        const bottomLeftWords = [grid[3], grid[4], grid[6], grid[7]];
                                                        currentGameData.quadrantClues.forEach(clue => {
                                                            if (clue.words.includes(word) && 
                                                                clue.words.every(w => bottomLeftWords.includes(w))) {
                                                                quadrants.push(clue.clue);
                                                            }
                                                        });
                                                    }
                                                    
                                                    // Bottom-right quadrant (positions 4,5,7,8)
                                                    if ((row === 1 && col === 1) || (row === 1 && col === 2) || 
                                                        (row === 2 && col === 1) || (row === 2 && col === 2)) {
                                                        const bottomRightWords = [grid[4], grid[5], grid[7], grid[8]];
                                                        currentGameData.quadrantClues.forEach(clue => {
                                                            if (clue.words.includes(word) && 
                                                                clue.words.every(w => bottomRightWords.includes(w))) {
                                                                quadrants.push(clue.clue);
                                                            }
                                                        });
                                                    }
                                                    
                                                    // Get the explanation for this word
                                                    explanationText = currentGameData.explanations[word] || '';
                                                }
                                            }
                                            
                                            return (
                                                <div 
                                                    key={idx} 
                                                    data-drop-index={idx} 
                                                    onDragOver={!isCenter ? handleDragOver : undefined} 
                                                    onDrop={!isCenter ? (e) => handleDrop(e, idx) : undefined} 
                                                    onDragEnter={!isCenter ? handleDragEnter : undefined} 
                                                    onDragLeave={!isCenter ? handleDragLeave : undefined}
                                                    onClick={() => handleCellClick(idx)}
                                                    className={`aspect-square rounded-lg border-4 flex items-center justify-center transition-all relative ${
                                                        isCenter ? 'locked-cell border-amber-500' : 
                                                        isSelected ? 'bg-blue-100 border-blue-500 transform scale-105' :
                                                        solved ? 'bg-green-50 border-green-400' :
                                                        'bg-slate-50 border-slate-400 hover:border-slate-500'
                                                    } ${!isCenter && !solved ? 'cursor-pointer' : ''}`}
                                                >
                                                    {isCenter && (
                                                        <div className="absolute -top-2 -right-2 bg-amber-500 rounded-full p-1 z-10">
                                                            <svg className="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
                                                            </svg>
                                                        </div>
                                                    )}
                                                    <div 
                                                        draggable={!isCenter && !solved} 
                                                        onDragStart={!isCenter && !solved ? (e) => handleDragStart(e, word, idx) : undefined} 
                                                        onDragEnd={handleDragEnd} 
                                                        className={`text-center p-1 w-full h-full flex flex-col items-center justify-center ${
                                                            !isCenter && !solved ? 'word-item' : ''
                                                        }`}
                                                    >
                                                        <div className={`font-bold text-base md:text-lg ${
                                                            isCenter ? 'text-amber-900' : 
                                                            solved ? 'text-green-800' : 'text-slate-800'
                                                        }`}>
                                                            {word}
                                                        </div>
                                                        {!isCenter && !solved && (
                                                            <div className="text-xs text-slate-400 mt-1">{idx + 1}</div>
                                                        )}
                                                        {solved && explanationText && (
                                                            <div className="text-[12px] text-slate-500 mt-1 px-1 leading-tight">
                                                                {explanationText.split(' / ').map((part, i) => (
                                                                    <div key={i}>{part}</div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    </div>
                                    
                                    <div className="mt-6 pt-6 border-t">
                                        <div className="text-center text-sm text-slate-600">
                                            <p className="font-semibold mb-2">
                                                {solved ? 'üéâ Puzzle solved! Explanations shown in grid.' : 'Arrange words by clicking or dragging'}
                                            </p>
                                            {!solved && (
                                                <p className="text-xs">
                                                    Use number keys 1-9 for quick selection ‚Ä¢ Press H for hints
                                                </p>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<ConnectionaryGame />, document.getElementById('root'));
    </script>
</body>
</html>
